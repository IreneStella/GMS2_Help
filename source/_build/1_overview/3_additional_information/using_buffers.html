<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Using Buffers</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/using_buffers.html";
</script>

</head>
<body><script type="text/JavaScript">
if (window.name != "content")
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> ");
</script>
<!-- !chm2web! -->

<script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } }
</script>
<h2><span title="Using Buffers">버퍼에 관하여</span></h2>

<div style="
position: relative;
left: 8px;
top: 4px;
"><small><small>현재 문서의 번역 참여자 : "IreneStella(euns****)", "왕초보 개발자ㅠ(alst****)"</small></small></div>

<div class="body-scroll">
<p><br>
</p>

<p><i>GameMaker Studio 2</i>는 GML에서 <b><span title="buffer">버퍼</b><span
class="box">*</span></span>를 처리하는 일련의 기능을 가지고
있습니다. 대부분의 사람들은 이 용어가 컴퓨터와 프로그래밍을 다룰 때 항상 사용되기
때문에 이 용어에 익숙합니다.(예 : 버퍼링) 하지만 그 단어에 익숙하다는 것이 여러분이
실제로 그 의미를 알고 있다는 것을 뜻하지는 않습니다. 따라서 이 페이지는 버퍼가
무엇이고, 실제로 어떻게 사용하는지를 <i>GameMaker Studio 2</i> 프로그래밍의 맥락
속에서 설명하는 것을 목표로 하고 있습니다. 일반적인 작동 방식은 프로그래밍 언어나
기술에 관계없이 유사하기 때문에 개념을 확실히 익히는 것이 매우 중요합니다.<br>
<br>
먼저 아래의 목차의 제목을 모두 읽어 흐름을 파악한 뒤, 순서대로 차근차근 읽는 것을
권장드립니다.
</p>

<blockquote><a name="buffers" id="buffers"></a> <label class=
"collapse" for="one">버퍼란?</label> <input id="one"
type="checkbox">
<div class="index_list">프로그래밍에서 말하는 <span title="buffer">버퍼<span
class="box">*</span></span>는 <span title="일명 램(RAM) 메모리">시스템
메모리<span class="box">*</span></span> 내의 공간으로서, 거의 모든 종류의 작은
데이터 <i><span title="packets(묶음)">패킷들<span class="box">*</span></span
></i>(통신, 색상, 객체 충돌 데이터 등)을 저장하는 데 사용됩니다. 시스템 메모리에
저장하는 특징 덕분에 접근 속도가 매우 빠르다는 큰 장점이 있습니다. 버퍼는 일반적으로
네트워크 통신을 수신 할 때나, 음악을 재생할 때, 게임에 체크 포인트를 저장할 때 등
매우 다양한 곳에 단기 기억 저장소로 사용됩니다. (이에 대한 자세한 내용은 아래 목록의
"버퍼 예제"을 참고해 주세요.) <img class="center" src=
"images/buffer_memory.png" alt="Buffer Memory">
버퍼는 <span title="byte (8 bit)">바이트<span class="box">*</span></span> 단위로
시스템 메모리에 공간을 할당하여 생성됩니다. 이 공간은 게임이 실행되는 동안이나 함수로
버퍼를 제거할 때까지는 계속 사용할 수 있습니다. 덧붙여, 게임이 <span title=
"not focus (현재 창이 선택되어 있지 않을 경우)">비활성화<span
class="box">*</span></span> 된 경우에도(예 : 창이 최소화 될 때, 다른 창을 띄울 때,
모바일 장치에서는 통화를 할 때 등) 버퍼가 여전히 유지됩니다. 하지만, 게임을 종료하면
모든 버퍼가 제거됩니다.<br>
<br>

<div class="note"><b>주의 : </b>게임을 "재시작"해도 버퍼가 지워지거나 제거되지
않지만, 재시작으로 인해 버퍼 ID(시스템 메모리상의 주소)를 잃어 사실상
이전에 생성했던 버퍼에 접근할 방법을 잃게 됩니다. 결국 <span title=
"컴퓨터 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상 - 위키">메모리
누수<span class="box">*</span></span> 현상이 발생해 게임이 강제 중단될 위험이
있으므로, 게임을 재시작하기 전에는 항상 모든 버퍼를 제거해야 한다는 점을 명심하시기
바랍니다!<br>
-여기서 말하는 "재시작"은 게임을 껐다 켜는 것을 뜻하지 않고, "game_restart()"와
같은 방법으로 프로그램을 종료하지 않고 재시작하는 것을 뜻합니다.
</div></div>
<br>
<a name="buffer_types" id="buffer_types"></a> <label class=
"collapse" for="two">버퍼 종류</label> <input id="two" type=
"checkbox">
<div class="index_list">
<i>GameMaker Studio 2</i>에서는 총 4가지 <span title="buffer">버퍼<span
class="box">*</span></span> 유형으로 생성할 수 있습니다. 특히, 버퍼는 고도로
최적화된 임시 저장 매체로 설계되었으므로, 저장하려는 데이터 유형에 적합한 버퍼를
생성해야 합니다. 그렇지 않으면 오류가 발생하거나, <i><span title="일명 랙">병목
현상<span class="box">*</span></span></i>이 발생할 수 있습니다. 이에 대해 자세히
설명하기 전에 GML에서 <b>상수</b>로 정의된 4가지 버퍼 유형을 살펴보겠습니다:<br>
<br>

<div class="compat">
<table>
<tr>
<th>상수</th>
<th>설명</th>
</tr>

<tr>
<td>buffer_fixed</td>
<td><br><b>고정 버퍼</b>라고 불리며, 가장 일반적인 버퍼입니다. 이름처럼 버퍼의 크기가
<i>고정</i>되어 생성할 때 정한 크기가 변하지 않는 점이 특징입니다. 다만, <a href="../../3_scripting/4_gml_reference/buffers/buffer_resize.html"
><tt>buffer_resize</tt></a> 함수로 크기를 변경하는 것이 가능합니다.<br>
<br></td>
</tr>

<tr class="alt">
<td>buffer_grow</td>
<td><br><b>성장 버퍼</b> 또는 <b>가변 버퍼</b>라고 불리며, 가장 많이 쓰는
버퍼입니다. 고정 버퍼와 달리 공간이 부족하면 <i>동적</i>으로 크기를 늘려 데이터를
저장하는 점이 특징입니다. 주의할 점은 생성할 때 정한 크기가 실제 저장되는 데이터
크기와 비슷해야 한다는 점입니다. <a href="../../3_scripting/4_gml_reference/buffers/buffer_resize.html"
><tt>buffer_resize</tt></a> 함수를 구지 쓰지 않아도 된다는 점이 큰 장점입니다.<br>
<br></td>
</tr>

<tr>
<td>buffer_wrap</td>
<td><br><b>회기 버퍼</b> 또는 <b>도돌이 버퍼</b>라고 불리며, 조금 독특한 버퍼입니다.
특이하게, 버퍼에 데이터가 가득차면 <i>처음</i>으로 돌아가 덮어 쓰기 시작합니다.
특별한 상황이 아니라면 쓰지 않는 것을 권장드립니다.<br>
<br></td>
</tr>

<tr class="alt">
<td>buffer_fast</td>
<td><br><b>고속 버퍼</b>라고 불리며, 계산에 "불필요한 부분"을 모두 뺀 특수 버퍼입니다.
덕분에 읽기/쓰기가 가장 빠른 특수 버퍼가 되었지만, 범용성을 희생하였기 때문에 오직
<tt>buffer_u8</tt>의 데이터 유형과 1 <span title="바이트 (8 bit)">byte<span
class="box">*</span></span> 정렬만을 사용해야 합니다. 많은 계산을 빠르게 처리해야할
때 사용하는 것을 추천드립니다. (데이터 유형 및 버퍼 정렬에 대한 정보는 아래의
<b>버퍼 데이터 유형</b>과 <b>버퍼 정렬</b> 목록에서 자세히 확인할 수 있습니다.)<br>
<br></td>
</tr>
</table>
</div>
<br>
<br>
소개한 4개의 상수들은 <i>GameMaker Studio 2</i>에서 사용할 수 있는 버퍼 종류이며,
어떤 종류를 선택하느냐에 따라 크게 달라집니다. 예를 들어, <b>성장 버퍼</b>는
"스크린샷"의 데이터를 저장하여 저장 게임을 만드는 데 사용됩니다. 실제 저장되는
데이터의 양을 모르기 때문입니다. <b>고속 버퍼</b>는 이미지의 RGB 데이터와 같은
값이 모두 0 ~ 255 또는 -128 및 127 사이인 것을 알 때 사용할 수 있을 것입니다.
<img class="center" src="images/buffer_types.png" alt="Buffer Types">
버퍼를 생성할 때는 항상 적합한 버퍼 종류와 크기로 생성해야 합니다. 일반적으로 버퍼는
예상되는 최대 데이터 크기를 수용할 수 있도록 생성해야 하며, 확실하지 않은 경우
<b>성장 버퍼</b>를 사용하여 버퍼 공간이 "부족"한 현상를 방지해야 합니다.<br>
<br>
버퍼를 생성하는 코드는 다음과 같습니다:<br>
<br>

<p class="code"><spon class="C5">player_buffer</spon> =
<spon class="C0">buffer_create</spon>(<spon class="C1">16384</spon>,
<spon class="C1">buffer_fixed</spon>, <spon class="C1">2</spon>);</p>
<br>
그러면 <b>16384 byte</b> 크기로 <b>2 byte</b> 씩 정렬하는 <b>고정 버퍼</b>가
생성되고, 버퍼의 고유 ID를 반환합니다. 이 ID는 나중에 읽기/쓰기 할 버퍼에 접근할
수 있도록 해줍니다. 이제 버퍼에 대한 기본 개념을 배웠으니, 앞서 언급한 <b>버퍼
데이터 유형</b>과 <b>버퍼 바이트 정렬</b>에 대해 알아보겠습니다.</div>
<br>
<a name="buffer_data_types" id="buffer_data_types"></a>
<label class="collapse" for="three">버퍼 데이터 유형</label>
<input id="three" type="checkbox">
<div class="index_list">When reading and writing data to a buffer,
you do it in ''chunks'' of data defined by their '''data type'''.
The '''data type''' sets the number of bytes allocated within the
buffer for the value being written, and it is essential that you
get this correct otherwise you will get some very strange results
(or even errors) for your code.<br>
<br>
Buffers are written to (and read from) <i>sequentially</i>, in that
one piece of data is written after another, with each piece of data
being of a set type. This means that you should ideally be aware of
what data you are writing to the buffer at all times. These <b>data
types</b> are defined in GML by the following <i>constants</i>:

<div class="compat">
<table>
<tr>
<th>Data Type Constant</th>
<th>Bytes</th>
<th>Description</th>
</tr>

<tr>
<td>buffer_u8</td>
<td>1</td>
<td><br>
An unsigned, 8bit integer. This is a positive value from 0 to
255.<br>
<br></td>
</tr>

<tr class="alt">
<td>buffer_s8</td>
<td>1</td>
<td><br>
A signed, 8bit integer. This can be a positive or negative value
from -128 to 127 (0 is classed as positive).<br>
<br></td>
</tr>

<tr>
<td>buffer_u16</td>
<td>2</td>
<td><br>
An unsigned, 16bit integer. This is a positive value from 0 -
65,535.<br>
<br></td>
</tr>

<tr class="alt">
<td>buffer_s16</td>
<td>2</td>
<td><br>
A signed, 16bit integer. This can be a positive or negative value
from -32,768 to 32,767 (0 is classed as positive).<br>
<br></td>
</tr>

<tr>
<td>buffer_f16</td>
<td>2</td>
<td><br>
A 16bit floating point number. This can be a positive or negative
value within the range of +/- 65504. <b>(Not currently
supported!)</b><br>
<br></td>
</tr>

<tr>
<td>buffer_u32</td>
<td>4</td>
<td><br>
An unsigned, 32bit integer. This is a positive value from 0 to
4,294,967,295.<br>
<br></td>
</tr>

<tr class="alt">
<td>buffer_s32</td>
<td>4</td>
<td><br>
A signed, 32bit integer. This can be a positive or negative value
from -2,147,483,648 to 2,147,483,647 (0 is classed as
positive).<br>
<br></td>
</tr>

<tr>
<td>buffer_f32</td>
<td>4</td>
<td><br>
A 32bit floating point number. This can be a positive or negative
value within the range of +/-16777216.<br>
<br></td>
</tr>

<tr class="alt">
<td>buffer_u64</td>
<td>8</td>
<td><br>
A 64bit unsigned integer value.<b>(Not currently supported by all
buffer functions!)</b><br>
<br></td>
</tr>

<tr>
<td>buffer_f64</td>
<td>8</td>
<td><br>
A 64bit floating point number.<br>
<br></td>
</tr>

<tr class="alt">
<td>buffer_bool</td>
<td>1</td>
<td><br>
A boolean value. Can only be either 1 or 0 (<tt>true</tt> or
<tt>false</tt>)<br>
<br></td>
</tr>

<tr>
<td>buffer_string</td>
<td>N/A</td>
<td><br>
This is a UTF-8 null terminated (0x00) string. Basically a
GameMaker string is dumped in the buffer, and a 0 is put at the
end.<br>
<br></td>
</tr>
</table>
</div>
<br>
<br>
So, say you have created a buffer and you want to write information
to it, then you would use something like the following code:<br>
<br>

<p class="code"><spon class="C0">buffer_write</spon>(<spon
class="C5">buff</spon>, <spon class="C1">buffer_bool</spon>, <spon
class="C1">global</spon>.<spon class="C7">Sound</spon>);<br>
<spon class="C0">buffer_write</spon>(<spon
class="C5">buff</spon>, <spon class="C1">buffer_bool</spon>, <spon
class="C1">global</spon>.<spon class="C7">Music</spon>);<br>
<spon class="C0">buffer_write</spon>(<spon
class="C5">buff</spon>, <spon class="C1">buffer_s16</spon>, <spon
class="C1">obj_Player</spon>.<spon class="C4">x</spon>);<br>
<spon class="C0">buffer_write</spon>(<spon
class="C5">buff</spon>, <spon class="C1">buffer_s16</spon>, <spon
class="C1">obj_Player</spon>.<spon class="C4">y</spon>);<br>
<spon class="C0">buffer_write</spon>(<spon
class="C5">buff</spon>, <spon class="C1">buffer_string</spon>, <spon
class="C1">global</spon>.<spon class="C7">Player_Name</spon>);<br></p>
<br>
looking at the example above you can see that you can write
different types of data to a buffer (you are only limited to a
specific data type when using the <b>fast</b> buffer type), and
this data will be added into the buffer consecutively (although its
actual position in the buffer will depend on its <b>byte
alignment</b>, explained below). This is the same for reading
information from the buffer too, and in the case of the example
given above, you would read from the buffer in the same order that
you wrote the data, checking for the same data type, eg:<br>
<br>

<p class="code">
<spon class="C1">global</spon>.<spon class="C7">Sound</spon> =
<spon class="C0">buffer_read</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_bool</spon>);<br>
<spon class="C1">global</spon>.<spon class="C7">Music</spon> =
<spon class="C0">buffer_read</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_bool</spon>);<br>
<spon class="C1">obj_Player</spon>.<spon class="C4">x</spon> =
<spon class="C0">buffer_read</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_s16</spon>);<br>
<spon class="C1">obj_Player</spon>.<spon class="C4">y</spon> =
<spon class="C0">buffer_read</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_s16</spon>);<br>
<spon class="C1">global</spon>.<spon class="C7">Player_Name</spon> =
<spon class="C0">buffer_read</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_string</spon>);<br></p>
<br>
As you can see, you read out information in the same order that you
read it into the buffer. For further information on how to add and
remove data from the buffer please see the <b>Examples</b> section
below.</div>
<br>
<a name="buffer_alignment" id="buffer_alignment"></a> <label class=
"collapse" for="four">버퍼 바이트 정렬</label> <input id="four"
type="checkbox">
<div class="index_list">If you have been reading through this page
you will have seen references to the <b>byte alignment</b> of a
buffer. This basically refers to the <i>position</i> that new data
will stored at within a given buffer. How does this work? Well, for
a single byte aligned buffer, each piece of data is written to the
buffer sequentially, with each new data piece being added directly
after the previous. However a 2 byte aligned buffer will write each
piece of data to intervals of 2 bytes, so that even if your initial
write is 1 byte of data, the <i>next</i> write will be moved to
align to two bytes. <img class="center" src=
"images/buffer_byte_alignment.png" alt="Buffer Byte Alignment"> So,
if your byte alignment is set to, say, 4 bytes and you write a
single piece of data which is 1 byte in size then do a <i>buffer
tell</i> (a <b>tell</b> gets the current position for
reading/writing for the buffer), you'll get an <i>offset</i> of 1
(the offset in this case is the number of bytes from the start of
the buffer to the current read/write position).<br>
<br>
However, if you write another piece of data, also 1 byte in size,
<i>then</i> do a buffer tell, you'll get an offset of 5 bytes (even
though you have only written 2 bytes of data) as the alignment has
<i>padded</i> the data to align it with the 4 byte buffer
alignment.<br>
<br>
Basically, what this means is that alignment will only affect
<i>where things are written to</i>, so if you do a buffer tell
after you write something, it'll return the current write position
which immediately follows the data you've previously written. Note,
however, that if you then write another piece of data, internally
the buffer will move the write position along to the next multiple
of the alignment size before actually writing the piece of
data.</div>
<br>
<a name="buffer_examples" id="buffer_examples"></a> <label class=
"collapse" for="five">버퍼 예제</label> <input id="five"
type="checkbox">
<div class="index_list">Below you can find some examples of common
uses for buffers.<br>
<br>
<a name="buffer_checkpoint" id="buffer_checkpoint"></a>
<label class="collapse" for="six">체크 포인트 만들기</label>
<input id="six" type="checkbox">
<div class="index_list">A simple example of how a buffer can be
used in any <i>GameMaker Studio 2</i> game for any platform, is the
function <a href=
"../../3_scripting/4_gml_reference/game/game_save_buffer.html"><tt>game_save_buffer</tt></a>.
This function will take a "snapshot" of the current game state and
save it to a pre-defined buffer, which can then be read from to
load the game at that point again.<br>
<br>

<div class="note"><b>NOTE:</b> This function is very limited and it
is designed for the beginner to get a checkpoint system up and
running quickly, but more advanced users may prefer to code their
own system using the <a href=
"../../3_scripting/4_gml_reference/file%20handling/index.html">File
functions</a>, due to the fact that the game will not save any of
the dynamic resources that you can create at run-time like data
structures, surfaces, added backgrounds and sprites etc...</div>
<br>
The first thing we need to do is create a new object to control the
saving and loading, so you would make one and give it a <b>Create
Event</b>. In this event, you could place the following code:<br>
<br>

<p class="code"><spon class="C5">SaveBuffer</spon> =
<spon class="C0">buffer_create</spon>(<spon class="C1">1024</spon>,
<spon class="C1">buffer_grow</spon>, <spon class="C1">1</spon>);<br>
<spon class="C5">StateSaved</spon> = <spon class="C1">false</spon>;<br></p>
<br>
The first line creates a <b>grow</b> buffer (since we don't know
the final size of the saved data) of 1024 bytes and aligned to 1
byte. A variable is then created to check against and see if the
game has been saved or not (this will be used for loading).<br>
<br>
Next we would add a <b>Keypress Event</b> (for example) in which we
will save the current game state to the created buffer:<br>
<br>

<p class="code"><spon class="C5">StateSaved</spon> =
<spon class="C1">true</spon>;<br>
<spon class="C0">buffer_seek</spon>(<spon class="C5">SaveBuffer</spon>,
<spon class="C1">buffer_seek_start</spon>, <spon class="C1">0</spon>);<br>
<spon class="C0">game_save_buffer</spon>(<spon
class="C5">SaveBuffer</spon>);<br></p>
<br>
The above will first set the control variable to true (so that this
is saved when we save the game to the buffer) and then <i>seek</i>
to the start of the buffer before writing the current save state
into it. Why do we use <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_seek.html"><tt>buffer_seek</tt></a>?
Well, as mentioned in the <b>Buffer Data Types</b> section above,
you read and write to a buffer from the last position that data was
added to it. This means that if you don't set the buffer
<i>tell</i> back to the start then when you save you will be adding
the data into the buffer at the current buffer read/write position,
so we use the function <tt>buffer_seek</tt> to move the <i>tell</i>
to the buffer start.<br>
<br>
We have now saved the current game state to a buffer. The next step
would be to code how to load it, probably in another <b>Keypress
Event</b>:<br>
<br>

<p class="code"><spon class="C0">if</spon>
<spon class="C5">StateSaved</spon><br>
<spon class="C0">{</spon><br><span class="TAB">&#9;</span><spon
class="C0">buffer_seek</spon>(<spon class="C5">SaveBuffer</spon>,
<spon class="C1">buffer_seek_start</spon>, <spon class="C1">0</spon>);<br>
<span class="TAB">&#9;</span><spon
class="C0">game_load_buffer</spon>(<spon class="C5">SaveBuffer</spon>);<br>
<spon class="C0">}</spon><br></p>
<br>
The game will then be loaded at the end of the event in which you
place the above code.<br>
<br>

<div class="note"><b>NOTE:</b> This is only for use in the same
room, and not for generating complete saved games for after your
game has been closed or restarted!</div>
<br>
The final thing to add to the controller object is a "clean up"
code. Buffers are stored in memory and as such if you do not clean
up when you are finished with them, you can get memory leaks that
will eventually lag and crash your game. So you would probably add
a <b>Room End Event</b> (from the <b>Other</b> event category)
with:<br>
<br>

<p class="code"><spon class="C0">buffer_delete</spon>(<spon
class="C5">SaveBuffer</spon>);<br></p>
<br>
This object can now be placed into a room and on a key press save
and load the room state from a buffer.<br>
<br></div>
<br>
<a name="buffer_networking" id="buffer_networking"></a>
<label class="collapse" for="seven">네트워크에 버퍼 사용하기</label>
<input id="seven" type="checkbox">
<div class="index_list">When working with the <i>GameMaker Studio
2</i> networking functions, you have to use buffers to create the
data<i>packet</i> that is being sent over the network connection.
This example intends to show how this is done, but due to the scope
of the networking possibilities, it is only designed to show how to
use the buffers themselves, and not the full networking system.<br>
<br>
The first thing we will show is the creation and use of a buffer
for the client side of the network connection. This buffer will be
used to create small data packets that can then be sent to the
server, so in the <b>Create Event</b> of an instance we would
assign a buffer like this:<br>
<br>

<p class="code"><spon class="C5">send_buff</spon> =
<spon class="C0">buffer_create</spon>(<spon class="C1">256</spon>,
<spon class="C1">buffer_grow</spon>, <spon class="C1">1</spon>);<br></p>
<br>
We make the buffer small (256bytes) as it is not intended for
holding large amounts of data, we make it a <i>grow</i> buffer to
ensure no errors should we need to add more data to be sent at any
time, and the alignment is set to one for convenience.<br>
<br>
Now, let's say that we want our client to send data to the server.
For that we need to create a buffer "packet", and in this example
we are going to send a <b>Key Press Event</b>, like when the player
presses <b>Left Arrow</b> to move around the game. To do this we
write the necessary data to the buffer first then send it off:<br>
<br>

<p class="code">
<spon class="C0">buffer_seek</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_seek_start</spon>, <spon class="C1">0</spon>);<br>
<spon class="C0">buffer_write</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_u8</spon>, <spon class="C1">1</spon>);<br>
<spon class="C0">buffer_write</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_s16</spon>, <spon class="C1">vk_left</spon>);<br>
<spon class="C0">buffer_write</spon>(<spon class="C5">buff</spon>,
<spon class="C1">buffer_bool</spon>, <spon class="C1">true</spon>);<br>
<spon class="C0">network_send_packet</spon>(<spon class="C1">client</spon>,
<spon class="C1">buff</spon>, <spon class="C0">buffer_tell</spon>(<spon
class="C5">buff</spon>));<br></p>
<br>
Before writing to the buffer we have set the "tell" to the start of
the buffer as networking <i>always</i> takes the data from the
<b>start</b> of a buffer. We then write the <i>check</i> value
(this will be used by the server to determine the type of event to
be processed), then the key being used, and then the state of the
key (in this case <tt>true</tt> for pressed). This buffer is then
sent as a data packet by the network function. Note that we do
<i>not</i> send the whole buffer! We only send the data written,
using the <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_tell.html"><tt>buffer_tell</tt></a>
function to return the current read/write position of the buffer
(remember that writing to the buffer moves the "tell" to the end of
what has been written).<br>
<br>
What about receiving the data on the server? The received data
packet that must be written into the buffer on the server and then
used to update the game. For that we would use the <a href=
"../../2_interface/1_editors/events/async_events.html">Networking
Asynchronous Event</a> in the network controller object of the
server, as this simplified code below shows:<br>
<br>

<p class="code"><spon class="C0">var</spon> <spon class="C6">buff</spon> =
<spon class="C0">ds_map_find_value</spon>(<spon class="C4">async_load</spon>,
<spon class="C2">"buffer"</spon>);<br>
<span class="C0">if</span> <span class="C5">cmd</span> ==
<spon class="C0">buffer_read</spon>(<spon class="C6">buff</spon>,
<spon class="C1">buffer_u8</spon>)<br><spon class="C0">{</spon><br><span
class="TAB">&#9;</span><spon class="C5">key</spon> =
<spon class="C0">buffer_read</spon>(<spon class="C6">buff</spon>,
<spon class="C1">buffer_s16</spon>);<br><span
class="TAB">&#9;</span><spon class="C5">key_state</spon> =
<spon class="C0">buffer_read</spon>(<spon class="C6">buff</spon>,
<spon class="C1">buffer_bool</spon>);<br><spon class="C0">}</spon><br></p>
<br>
The asynchronous event will contain a special temporary
<tt>ds_map</tt> (it is removed at the end of the event
automatically) which contains different information depending on
the type of incoming data from the network. In this case, we are
assuming that the map has been checked and found to be a buffer
data packet sent from a client. We now check the first piece of
data that is in the buffer to see what kind of event has been sent
- in this case the value "1" represents a <i>key</i> event, however
when coding these things you should define <b>constants</b> to hold
these values to simplify things - and then store the key being
pressed and its state (<tt>true</tt> = pressed, <tt>false</tt> =
released). This information would then be used to update all the
clients with the new status of the sending client player.<br>
<br>

<div class="note"><b>NOTE:</b> The buffer that is created from the
ds_map is automatically removed at the end of the Network
Asynchronous Event so there is no need to use <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_delete.html"><tt>buffer_delete</tt></a>
here.</div></div>

<br>
<a name="buffer_sound" id="buffer_sound"></a>
<label class="collapse" for="eight">버퍼로 음악 파일 재생하기 &lt;유저&gt;</label>
<input id="eight" type="checkbox">
<div class="index_list">
&lt;이 내용은 KGMC-IreneStella님에 의해 작성된 예제입니다.&gt;<br>
<br>
준비중...
</div>

</div></blockquote>

<p><br>
</p>
</div>

<div class="footer">
<div class="buttons">
<div class="clear">
<div style="float:left">Back: <a href="index.html">Additional
Information Index</a></div>

<div style="float:right">Next: <a href="texture_pages.html">Texture
Pages</a></div>
</div>
</div>

<h5>© Copyright YoYo Games Ltd. 2019 All Rights Reserved</h5>
</div>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview');
</script>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
